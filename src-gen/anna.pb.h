// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: anna.proto

#ifndef PROTOBUF_INCLUDED_anna_2eproto
#define PROTOBUF_INCLUDED_anna_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_anna_2eproto 

namespace protobuf_anna_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[17];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_anna_2eproto
class KeyAddressRequest;
class KeyAddressRequestDefaultTypeInternal;
extern KeyAddressRequestDefaultTypeInternal _KeyAddressRequest_default_instance_;
class KeyAddressResponse;
class KeyAddressResponseDefaultTypeInternal;
extern KeyAddressResponseDefaultTypeInternal _KeyAddressResponse_default_instance_;
class KeyAddressResponse_KeyAddress;
class KeyAddressResponse_KeyAddressDefaultTypeInternal;
extern KeyAddressResponse_KeyAddressDefaultTypeInternal _KeyAddressResponse_KeyAddress_default_instance_;
class KeyRequest;
class KeyRequestDefaultTypeInternal;
extern KeyRequestDefaultTypeInternal _KeyRequest_default_instance_;
class KeyResponse;
class KeyResponseDefaultTypeInternal;
extern KeyResponseDefaultTypeInternal _KeyResponse_default_instance_;
class KeyTuple;
class KeyTupleDefaultTypeInternal;
extern KeyTupleDefaultTypeInternal _KeyTuple_default_instance_;
class KeyVersion;
class KeyVersionDefaultTypeInternal;
extern KeyVersionDefaultTypeInternal _KeyVersion_default_instance_;
class KeyVersionList;
class KeyVersionListDefaultTypeInternal;
extern KeyVersionListDefaultTypeInternal _KeyVersionList_default_instance_;
class KeyVersion_VectorClockEntry_DoNotUse;
class KeyVersion_VectorClockEntry_DoNotUseDefaultTypeInternal;
extern KeyVersion_VectorClockEntry_DoNotUseDefaultTypeInternal _KeyVersion_VectorClockEntry_DoNotUse_default_instance_;
class LWWValue;
class LWWValueDefaultTypeInternal;
extern LWWValueDefaultTypeInternal _LWWValue_default_instance_;
class MultiKeyCausalValue;
class MultiKeyCausalValueDefaultTypeInternal;
extern MultiKeyCausalValueDefaultTypeInternal _MultiKeyCausalValue_default_instance_;
class MultiKeyCausalValue_VectorClockEntry_DoNotUse;
class MultiKeyCausalValue_VectorClockEntry_DoNotUseDefaultTypeInternal;
extern MultiKeyCausalValue_VectorClockEntry_DoNotUseDefaultTypeInternal _MultiKeyCausalValue_VectorClockEntry_DoNotUse_default_instance_;
class PriorityValue;
class PriorityValueDefaultTypeInternal;
extern PriorityValueDefaultTypeInternal _PriorityValue_default_instance_;
class SetValue;
class SetValueDefaultTypeInternal;
extern SetValueDefaultTypeInternal _SetValue_default_instance_;
class SingleKeyCausalValue;
class SingleKeyCausalValueDefaultTypeInternal;
extern SingleKeyCausalValueDefaultTypeInternal _SingleKeyCausalValue_default_instance_;
class SingleKeyCausalValue_VectorClockEntry_DoNotUse;
class SingleKeyCausalValue_VectorClockEntry_DoNotUseDefaultTypeInternal;
extern SingleKeyCausalValue_VectorClockEntry_DoNotUseDefaultTypeInternal _SingleKeyCausalValue_VectorClockEntry_DoNotUse_default_instance_;
class StringSet;
class StringSetDefaultTypeInternal;
extern StringSetDefaultTypeInternal _StringSet_default_instance_;
namespace google {
namespace protobuf {
template<> ::KeyAddressRequest* Arena::CreateMaybeMessage<::KeyAddressRequest>(Arena*);
template<> ::KeyAddressResponse* Arena::CreateMaybeMessage<::KeyAddressResponse>(Arena*);
template<> ::KeyAddressResponse_KeyAddress* Arena::CreateMaybeMessage<::KeyAddressResponse_KeyAddress>(Arena*);
template<> ::KeyRequest* Arena::CreateMaybeMessage<::KeyRequest>(Arena*);
template<> ::KeyResponse* Arena::CreateMaybeMessage<::KeyResponse>(Arena*);
template<> ::KeyTuple* Arena::CreateMaybeMessage<::KeyTuple>(Arena*);
template<> ::KeyVersion* Arena::CreateMaybeMessage<::KeyVersion>(Arena*);
template<> ::KeyVersionList* Arena::CreateMaybeMessage<::KeyVersionList>(Arena*);
template<> ::KeyVersion_VectorClockEntry_DoNotUse* Arena::CreateMaybeMessage<::KeyVersion_VectorClockEntry_DoNotUse>(Arena*);
template<> ::LWWValue* Arena::CreateMaybeMessage<::LWWValue>(Arena*);
template<> ::MultiKeyCausalValue* Arena::CreateMaybeMessage<::MultiKeyCausalValue>(Arena*);
template<> ::MultiKeyCausalValue_VectorClockEntry_DoNotUse* Arena::CreateMaybeMessage<::MultiKeyCausalValue_VectorClockEntry_DoNotUse>(Arena*);
template<> ::PriorityValue* Arena::CreateMaybeMessage<::PriorityValue>(Arena*);
template<> ::SetValue* Arena::CreateMaybeMessage<::SetValue>(Arena*);
template<> ::SingleKeyCausalValue* Arena::CreateMaybeMessage<::SingleKeyCausalValue>(Arena*);
template<> ::SingleKeyCausalValue_VectorClockEntry_DoNotUse* Arena::CreateMaybeMessage<::SingleKeyCausalValue_VectorClockEntry_DoNotUse>(Arena*);
template<> ::StringSet* Arena::CreateMaybeMessage<::StringSet>(Arena*);
}  // namespace protobuf
}  // namespace google

enum RequestType {
  RT_UNSPECIFIED = 0,
  GET = 1,
  PUT = 2,
  RequestType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  RequestType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool RequestType_IsValid(int value);
const RequestType RequestType_MIN = RT_UNSPECIFIED;
const RequestType RequestType_MAX = PUT;
const int RequestType_ARRAYSIZE = RequestType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RequestType_descriptor();
inline const ::std::string& RequestType_Name(RequestType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RequestType_descriptor(), value);
}
inline bool RequestType_Parse(
    const ::std::string& name, RequestType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RequestType>(
    RequestType_descriptor(), name, value);
}
enum LatticeType {
  NONE = 0,
  LWW = 1,
  SET = 2,
  SINGLE_CAUSAL = 3,
  MULTI_CAUSAL = 4,
  ORDERED_SET = 5,
  PRIORITY = 6,
  LatticeType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  LatticeType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool LatticeType_IsValid(int value);
const LatticeType LatticeType_MIN = NONE;
const LatticeType LatticeType_MAX = PRIORITY;
const int LatticeType_ARRAYSIZE = LatticeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LatticeType_descriptor();
inline const ::std::string& LatticeType_Name(LatticeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LatticeType_descriptor(), value);
}
inline bool LatticeType_Parse(
    const ::std::string& name, LatticeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LatticeType>(
    LatticeType_descriptor(), name, value);
}
enum AnnaError {
  NO_ERROR = 0,
  KEY_DNE = 1,
  WRONG_THREAD = 2,
  TIMEOUT = 3,
  LATTICE = 4,
  NO_SERVERS = 5,
  AnnaError_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  AnnaError_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool AnnaError_IsValid(int value);
const AnnaError AnnaError_MIN = NO_ERROR;
const AnnaError AnnaError_MAX = NO_SERVERS;
const int AnnaError_ARRAYSIZE = AnnaError_MAX + 1;

const ::google::protobuf::EnumDescriptor* AnnaError_descriptor();
inline const ::std::string& AnnaError_Name(AnnaError value) {
  return ::google::protobuf::internal::NameOfEnum(
    AnnaError_descriptor(), value);
}
inline bool AnnaError_Parse(
    const ::std::string& name, AnnaError* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AnnaError>(
    AnnaError_descriptor(), name, value);
}
// ===================================================================

class StringSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:StringSet) */ {
 public:
  StringSet();
  virtual ~StringSet();

  StringSet(const StringSet& from);

  inline StringSet& operator=(const StringSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringSet(StringSet&& from) noexcept
    : StringSet() {
    *this = ::std::move(from);
  }

  inline StringSet& operator=(StringSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const StringSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringSet* internal_default_instance() {
    return reinterpret_cast<const StringSet*>(
               &_StringSet_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(StringSet* other);
  friend void swap(StringSet& a, StringSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringSet* New() const final {
    return CreateMaybeMessage<StringSet>(NULL);
  }

  StringSet* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringSet>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringSet& from);
  void MergeFrom(const StringSet& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // @@protoc_insertion_point(class_scope:StringSet)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyVersion_VectorClockEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<KeyVersion_VectorClockEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<KeyVersion_VectorClockEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > SuperType;
  KeyVersion_VectorClockEntry_DoNotUse();
  KeyVersion_VectorClockEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const KeyVersion_VectorClockEntry_DoNotUse& other);
  static const KeyVersion_VectorClockEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const KeyVersion_VectorClockEntry_DoNotUse*>(&_KeyVersion_VectorClockEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class KeyVersion : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyVersion) */ {
 public:
  KeyVersion();
  virtual ~KeyVersion();

  KeyVersion(const KeyVersion& from);

  inline KeyVersion& operator=(const KeyVersion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyVersion(KeyVersion&& from) noexcept
    : KeyVersion() {
    *this = ::std::move(from);
  }

  inline KeyVersion& operator=(KeyVersion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyVersion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyVersion* internal_default_instance() {
    return reinterpret_cast<const KeyVersion*>(
               &_KeyVersion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(KeyVersion* other);
  friend void swap(KeyVersion& a, KeyVersion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyVersion* New() const final {
    return CreateMaybeMessage<KeyVersion>(NULL);
  }

  KeyVersion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyVersion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyVersion& from);
  void MergeFrom(const KeyVersion& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVersion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, uint32> vector_clock = 2;
  int vector_clock_size() const;
  void clear_vector_clock();
  static const int kVectorClockFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >&
      vector_clock() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >*
      mutable_vector_clock();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:KeyVersion)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      KeyVersion_VectorClockEntry_DoNotUse,
      ::std::string, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > vector_clock_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyVersionList : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyVersionList) */ {
 public:
  KeyVersionList();
  virtual ~KeyVersionList();

  KeyVersionList(const KeyVersionList& from);

  inline KeyVersionList& operator=(const KeyVersionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyVersionList(KeyVersionList&& from) noexcept
    : KeyVersionList() {
    *this = ::std::move(from);
  }

  inline KeyVersionList& operator=(KeyVersionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyVersionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyVersionList* internal_default_instance() {
    return reinterpret_cast<const KeyVersionList*>(
               &_KeyVersionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(KeyVersionList* other);
  friend void swap(KeyVersionList& a, KeyVersionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyVersionList* New() const final {
    return CreateMaybeMessage<KeyVersionList>(NULL);
  }

  KeyVersionList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyVersionList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyVersionList& from);
  void MergeFrom(const KeyVersionList& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyVersionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyVersion keys = 1;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 1;
  ::KeyVersion* mutable_keys(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyVersion >*
      mutable_keys();
  const ::KeyVersion& keys(int index) const;
  ::KeyVersion* add_keys();
  const ::google::protobuf::RepeatedPtrField< ::KeyVersion >&
      keys() const;

  // @@protoc_insertion_point(class_scope:KeyVersionList)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyVersion > keys_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyTuple : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyTuple) */ {
 public:
  KeyTuple();
  virtual ~KeyTuple();

  KeyTuple(const KeyTuple& from);

  inline KeyTuple& operator=(const KeyTuple& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyTuple(KeyTuple&& from) noexcept
    : KeyTuple() {
    *this = ::std::move(from);
  }

  inline KeyTuple& operator=(KeyTuple&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyTuple& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyTuple* internal_default_instance() {
    return reinterpret_cast<const KeyTuple*>(
               &_KeyTuple_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(KeyTuple* other);
  friend void swap(KeyTuple& a, KeyTuple& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyTuple* New() const final {
    return CreateMaybeMessage<KeyTuple>(NULL);
  }

  KeyTuple* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyTuple>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyTuple& from);
  void MergeFrom(const KeyTuple& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyTuple* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // bytes payload = 4;
  void clear_payload();
  static const int kPayloadFieldNumber = 4;
  const ::std::string& payload() const;
  void set_payload(const ::std::string& value);
  #if LANG_CXX11
  void set_payload(::std::string&& value);
  #endif
  void set_payload(const char* value);
  void set_payload(const void* value, size_t size);
  ::std::string* mutable_payload();
  ::std::string* release_payload();
  void set_allocated_payload(::std::string* payload);

  // .LatticeType lattice_type = 2;
  void clear_lattice_type();
  static const int kLatticeTypeFieldNumber = 2;
  ::LatticeType lattice_type() const;
  void set_lattice_type(::LatticeType value);

  // .AnnaError error = 3;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  ::AnnaError error() const;
  void set_error(::AnnaError value);

  // uint32 address_cache_size = 5;
  void clear_address_cache_size();
  static const int kAddressCacheSizeFieldNumber = 5;
  ::google::protobuf::uint32 address_cache_size() const;
  void set_address_cache_size(::google::protobuf::uint32 value);

  // bool invalidate = 6;
  void clear_invalidate();
  static const int kInvalidateFieldNumber = 6;
  bool invalidate() const;
  void set_invalidate(bool value);

  // @@protoc_insertion_point(class_scope:KeyTuple)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr payload_;
  int lattice_type_;
  int error_;
  ::google::protobuf::uint32 address_cache_size_;
  bool invalidate_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyRequest) */ {
 public:
  KeyRequest();
  virtual ~KeyRequest();

  KeyRequest(const KeyRequest& from);

  inline KeyRequest& operator=(const KeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyRequest(KeyRequest&& from) noexcept
    : KeyRequest() {
    *this = ::std::move(from);
  }

  inline KeyRequest& operator=(KeyRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyRequest* internal_default_instance() {
    return reinterpret_cast<const KeyRequest*>(
               &_KeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(KeyRequest* other);
  friend void swap(KeyRequest& a, KeyRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyRequest* New() const final {
    return CreateMaybeMessage<KeyRequest>(NULL);
  }

  KeyRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyRequest& from);
  void MergeFrom(const KeyRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyTuple tuples = 2;
  int tuples_size() const;
  void clear_tuples();
  static const int kTuplesFieldNumber = 2;
  ::KeyTuple* mutable_tuples(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyTuple >*
      mutable_tuples();
  const ::KeyTuple& tuples(int index) const;
  ::KeyTuple* add_tuples();
  const ::google::protobuf::RepeatedPtrField< ::KeyTuple >&
      tuples() const;

  // string response_address = 3;
  void clear_response_address();
  static const int kResponseAddressFieldNumber = 3;
  const ::std::string& response_address() const;
  void set_response_address(const ::std::string& value);
  #if LANG_CXX11
  void set_response_address(::std::string&& value);
  #endif
  void set_response_address(const char* value);
  void set_response_address(const char* value, size_t size);
  ::std::string* mutable_response_address();
  ::std::string* release_response_address();
  void set_allocated_response_address(::std::string* response_address);

  // string request_id = 4;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 4;
  const ::std::string& request_id() const;
  void set_request_id(const ::std::string& value);
  #if LANG_CXX11
  void set_request_id(::std::string&& value);
  #endif
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  ::std::string* mutable_request_id();
  ::std::string* release_request_id();
  void set_allocated_request_id(::std::string* request_id);

  // .RequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::RequestType type() const;
  void set_type(::RequestType value);

  // @@protoc_insertion_point(class_scope:KeyRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyTuple > tuples_;
  ::google::protobuf::internal::ArenaStringPtr response_address_;
  ::google::protobuf::internal::ArenaStringPtr request_id_;
  int type_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyResponse) */ {
 public:
  KeyResponse();
  virtual ~KeyResponse();

  KeyResponse(const KeyResponse& from);

  inline KeyResponse& operator=(const KeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyResponse(KeyResponse&& from) noexcept
    : KeyResponse() {
    *this = ::std::move(from);
  }

  inline KeyResponse& operator=(KeyResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyResponse* internal_default_instance() {
    return reinterpret_cast<const KeyResponse*>(
               &_KeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(KeyResponse* other);
  friend void swap(KeyResponse& a, KeyResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyResponse* New() const final {
    return CreateMaybeMessage<KeyResponse>(NULL);
  }

  KeyResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyResponse& from);
  void MergeFrom(const KeyResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .KeyTuple tuples = 2;
  int tuples_size() const;
  void clear_tuples();
  static const int kTuplesFieldNumber = 2;
  ::KeyTuple* mutable_tuples(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyTuple >*
      mutable_tuples();
  const ::KeyTuple& tuples(int index) const;
  ::KeyTuple* add_tuples();
  const ::google::protobuf::RepeatedPtrField< ::KeyTuple >&
      tuples() const;

  // string response_id = 3;
  void clear_response_id();
  static const int kResponseIdFieldNumber = 3;
  const ::std::string& response_id() const;
  void set_response_id(const ::std::string& value);
  #if LANG_CXX11
  void set_response_id(::std::string&& value);
  #endif
  void set_response_id(const char* value);
  void set_response_id(const char* value, size_t size);
  ::std::string* mutable_response_id();
  ::std::string* release_response_id();
  void set_allocated_response_id(::std::string* response_id);

  // .RequestType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::RequestType type() const;
  void set_type(::RequestType value);

  // .AnnaError error = 4;
  void clear_error();
  static const int kErrorFieldNumber = 4;
  ::AnnaError error() const;
  void set_error(::AnnaError value);

  // @@protoc_insertion_point(class_scope:KeyResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyTuple > tuples_;
  ::google::protobuf::internal::ArenaStringPtr response_id_;
  int type_;
  int error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyAddressRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyAddressRequest) */ {
 public:
  KeyAddressRequest();
  virtual ~KeyAddressRequest();

  KeyAddressRequest(const KeyAddressRequest& from);

  inline KeyAddressRequest& operator=(const KeyAddressRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyAddressRequest(KeyAddressRequest&& from) noexcept
    : KeyAddressRequest() {
    *this = ::std::move(from);
  }

  inline KeyAddressRequest& operator=(KeyAddressRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyAddressRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyAddressRequest* internal_default_instance() {
    return reinterpret_cast<const KeyAddressRequest*>(
               &_KeyAddressRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(KeyAddressRequest* other);
  friend void swap(KeyAddressRequest& a, KeyAddressRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyAddressRequest* New() const final {
    return CreateMaybeMessage<KeyAddressRequest>(NULL);
  }

  KeyAddressRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyAddressRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyAddressRequest& from);
  void MergeFrom(const KeyAddressRequest& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyAddressRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string keys = 2;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 2;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_keys(int index, ::std::string&& value);
  #endif
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  #if LANG_CXX11
  void add_keys(::std::string&& value);
  #endif
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // string response_address = 1;
  void clear_response_address();
  static const int kResponseAddressFieldNumber = 1;
  const ::std::string& response_address() const;
  void set_response_address(const ::std::string& value);
  #if LANG_CXX11
  void set_response_address(::std::string&& value);
  #endif
  void set_response_address(const char* value);
  void set_response_address(const char* value, size_t size);
  ::std::string* mutable_response_address();
  ::std::string* release_response_address();
  void set_allocated_response_address(::std::string* response_address);

  // string request_id = 3;
  void clear_request_id();
  static const int kRequestIdFieldNumber = 3;
  const ::std::string& request_id() const;
  void set_request_id(const ::std::string& value);
  #if LANG_CXX11
  void set_request_id(::std::string&& value);
  #endif
  void set_request_id(const char* value);
  void set_request_id(const char* value, size_t size);
  ::std::string* mutable_request_id();
  ::std::string* release_request_id();
  void set_allocated_request_id(::std::string* request_id);

  // @@protoc_insertion_point(class_scope:KeyAddressRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr response_address_;
  ::google::protobuf::internal::ArenaStringPtr request_id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyAddressResponse_KeyAddress : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyAddressResponse.KeyAddress) */ {
 public:
  KeyAddressResponse_KeyAddress();
  virtual ~KeyAddressResponse_KeyAddress();

  KeyAddressResponse_KeyAddress(const KeyAddressResponse_KeyAddress& from);

  inline KeyAddressResponse_KeyAddress& operator=(const KeyAddressResponse_KeyAddress& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyAddressResponse_KeyAddress(KeyAddressResponse_KeyAddress&& from) noexcept
    : KeyAddressResponse_KeyAddress() {
    *this = ::std::move(from);
  }

  inline KeyAddressResponse_KeyAddress& operator=(KeyAddressResponse_KeyAddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyAddressResponse_KeyAddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyAddressResponse_KeyAddress* internal_default_instance() {
    return reinterpret_cast<const KeyAddressResponse_KeyAddress*>(
               &_KeyAddressResponse_KeyAddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(KeyAddressResponse_KeyAddress* other);
  friend void swap(KeyAddressResponse_KeyAddress& a, KeyAddressResponse_KeyAddress& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyAddressResponse_KeyAddress* New() const final {
    return CreateMaybeMessage<KeyAddressResponse_KeyAddress>(NULL);
  }

  KeyAddressResponse_KeyAddress* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyAddressResponse_KeyAddress>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyAddressResponse_KeyAddress& from);
  void MergeFrom(const KeyAddressResponse_KeyAddress& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyAddressResponse_KeyAddress* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string ips = 2;
  int ips_size() const;
  void clear_ips();
  static const int kIpsFieldNumber = 2;
  const ::std::string& ips(int index) const;
  ::std::string* mutable_ips(int index);
  void set_ips(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_ips(int index, ::std::string&& value);
  #endif
  void set_ips(int index, const char* value);
  void set_ips(int index, const char* value, size_t size);
  ::std::string* add_ips();
  void add_ips(const ::std::string& value);
  #if LANG_CXX11
  void add_ips(::std::string&& value);
  #endif
  void add_ips(const char* value);
  void add_ips(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& ips() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_ips();

  // string key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  #if LANG_CXX11
  void set_key(::std::string&& value);
  #endif
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // @@protoc_insertion_point(class_scope:KeyAddressResponse.KeyAddress)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> ips_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class KeyAddressResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:KeyAddressResponse) */ {
 public:
  KeyAddressResponse();
  virtual ~KeyAddressResponse();

  KeyAddressResponse(const KeyAddressResponse& from);

  inline KeyAddressResponse& operator=(const KeyAddressResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  KeyAddressResponse(KeyAddressResponse&& from) noexcept
    : KeyAddressResponse() {
    *this = ::std::move(from);
  }

  inline KeyAddressResponse& operator=(KeyAddressResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyAddressResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const KeyAddressResponse* internal_default_instance() {
    return reinterpret_cast<const KeyAddressResponse*>(
               &_KeyAddressResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(KeyAddressResponse* other);
  friend void swap(KeyAddressResponse& a, KeyAddressResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline KeyAddressResponse* New() const final {
    return CreateMaybeMessage<KeyAddressResponse>(NULL);
  }

  KeyAddressResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<KeyAddressResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const KeyAddressResponse& from);
  void MergeFrom(const KeyAddressResponse& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyAddressResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef KeyAddressResponse_KeyAddress KeyAddress;

  // accessors -------------------------------------------------------

  // repeated .KeyAddressResponse.KeyAddress addresses = 1;
  int addresses_size() const;
  void clear_addresses();
  static const int kAddressesFieldNumber = 1;
  ::KeyAddressResponse_KeyAddress* mutable_addresses(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyAddressResponse_KeyAddress >*
      mutable_addresses();
  const ::KeyAddressResponse_KeyAddress& addresses(int index) const;
  ::KeyAddressResponse_KeyAddress* add_addresses();
  const ::google::protobuf::RepeatedPtrField< ::KeyAddressResponse_KeyAddress >&
      addresses() const;

  // string response_id = 3;
  void clear_response_id();
  static const int kResponseIdFieldNumber = 3;
  const ::std::string& response_id() const;
  void set_response_id(const ::std::string& value);
  #if LANG_CXX11
  void set_response_id(::std::string&& value);
  #endif
  void set_response_id(const char* value);
  void set_response_id(const char* value, size_t size);
  ::std::string* mutable_response_id();
  ::std::string* release_response_id();
  void set_allocated_response_id(::std::string* response_id);

  // .AnnaError error = 2;
  void clear_error();
  static const int kErrorFieldNumber = 2;
  ::AnnaError error() const;
  void set_error(::AnnaError value);

  // @@protoc_insertion_point(class_scope:KeyAddressResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::KeyAddressResponse_KeyAddress > addresses_;
  ::google::protobuf::internal::ArenaStringPtr response_id_;
  int error_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class LWWValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:LWWValue) */ {
 public:
  LWWValue();
  virtual ~LWWValue();

  LWWValue(const LWWValue& from);

  inline LWWValue& operator=(const LWWValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LWWValue(LWWValue&& from) noexcept
    : LWWValue() {
    *this = ::std::move(from);
  }

  inline LWWValue& operator=(LWWValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const LWWValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LWWValue* internal_default_instance() {
    return reinterpret_cast<const LWWValue*>(
               &_LWWValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(LWWValue* other);
  friend void swap(LWWValue& a, LWWValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LWWValue* New() const final {
    return CreateMaybeMessage<LWWValue>(NULL);
  }

  LWWValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LWWValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LWWValue& from);
  void MergeFrom(const LWWValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LWWValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // uint64 timestamp = 1;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 1;
  ::google::protobuf::uint64 timestamp() const;
  void set_timestamp(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:LWWValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::uint64 timestamp_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SetValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SetValue) */ {
 public:
  SetValue();
  virtual ~SetValue();

  SetValue(const SetValue& from);

  inline SetValue& operator=(const SetValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SetValue(SetValue&& from) noexcept
    : SetValue() {
    *this = ::std::move(from);
  }

  inline SetValue& operator=(SetValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SetValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SetValue* internal_default_instance() {
    return reinterpret_cast<const SetValue*>(
               &_SetValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(SetValue* other);
  friend void swap(SetValue& a, SetValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SetValue* New() const final {
    return CreateMaybeMessage<SetValue>(NULL);
  }

  SetValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SetValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SetValue& from);
  void MergeFrom(const SetValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SetValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes values = 1;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 1;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:SetValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SingleKeyCausalValue_VectorClockEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<SingleKeyCausalValue_VectorClockEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<SingleKeyCausalValue_VectorClockEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > SuperType;
  SingleKeyCausalValue_VectorClockEntry_DoNotUse();
  SingleKeyCausalValue_VectorClockEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const SingleKeyCausalValue_VectorClockEntry_DoNotUse& other);
  static const SingleKeyCausalValue_VectorClockEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SingleKeyCausalValue_VectorClockEntry_DoNotUse*>(&_SingleKeyCausalValue_VectorClockEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class SingleKeyCausalValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:SingleKeyCausalValue) */ {
 public:
  SingleKeyCausalValue();
  virtual ~SingleKeyCausalValue();

  SingleKeyCausalValue(const SingleKeyCausalValue& from);

  inline SingleKeyCausalValue& operator=(const SingleKeyCausalValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  SingleKeyCausalValue(SingleKeyCausalValue&& from) noexcept
    : SingleKeyCausalValue() {
    *this = ::std::move(from);
  }

  inline SingleKeyCausalValue& operator=(SingleKeyCausalValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const SingleKeyCausalValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const SingleKeyCausalValue* internal_default_instance() {
    return reinterpret_cast<const SingleKeyCausalValue*>(
               &_SingleKeyCausalValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(SingleKeyCausalValue* other);
  friend void swap(SingleKeyCausalValue& a, SingleKeyCausalValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline SingleKeyCausalValue* New() const final {
    return CreateMaybeMessage<SingleKeyCausalValue>(NULL);
  }

  SingleKeyCausalValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<SingleKeyCausalValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const SingleKeyCausalValue& from);
  void MergeFrom(const SingleKeyCausalValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SingleKeyCausalValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, uint32> vector_clock = 1;
  int vector_clock_size() const;
  void clear_vector_clock();
  static const int kVectorClockFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >&
      vector_clock() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >*
      mutable_vector_clock();

  // repeated bytes values = 2;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 2;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:SingleKeyCausalValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      SingleKeyCausalValue_VectorClockEntry_DoNotUse,
      ::std::string, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > vector_clock_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MultiKeyCausalValue_VectorClockEntry_DoNotUse : public ::google::protobuf::internal::MapEntry<MultiKeyCausalValue_VectorClockEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > {
public:
  typedef ::google::protobuf::internal::MapEntry<MultiKeyCausalValue_VectorClockEntry_DoNotUse, 
    ::std::string, ::google::protobuf::uint32,
    ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
    ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
    0 > SuperType;
  MultiKeyCausalValue_VectorClockEntry_DoNotUse();
  MultiKeyCausalValue_VectorClockEntry_DoNotUse(::google::protobuf::Arena* arena);
  void MergeFrom(const MultiKeyCausalValue_VectorClockEntry_DoNotUse& other);
  static const MultiKeyCausalValue_VectorClockEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const MultiKeyCausalValue_VectorClockEntry_DoNotUse*>(&_MultiKeyCausalValue_VectorClockEntry_DoNotUse_default_instance_); }
  void MergeFrom(const ::google::protobuf::Message& other) final;
  ::google::protobuf::Metadata GetMetadata() const;
};

// -------------------------------------------------------------------

class MultiKeyCausalValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:MultiKeyCausalValue) */ {
 public:
  MultiKeyCausalValue();
  virtual ~MultiKeyCausalValue();

  MultiKeyCausalValue(const MultiKeyCausalValue& from);

  inline MultiKeyCausalValue& operator=(const MultiKeyCausalValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  MultiKeyCausalValue(MultiKeyCausalValue&& from) noexcept
    : MultiKeyCausalValue() {
    *this = ::std::move(from);
  }

  inline MultiKeyCausalValue& operator=(MultiKeyCausalValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const MultiKeyCausalValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const MultiKeyCausalValue* internal_default_instance() {
    return reinterpret_cast<const MultiKeyCausalValue*>(
               &_MultiKeyCausalValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(MultiKeyCausalValue* other);
  friend void swap(MultiKeyCausalValue& a, MultiKeyCausalValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline MultiKeyCausalValue* New() const final {
    return CreateMaybeMessage<MultiKeyCausalValue>(NULL);
  }

  MultiKeyCausalValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<MultiKeyCausalValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const MultiKeyCausalValue& from);
  void MergeFrom(const MultiKeyCausalValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MultiKeyCausalValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, uint32> vector_clock = 1;
  int vector_clock_size() const;
  void clear_vector_clock();
  static const int kVectorClockFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >&
      vector_clock() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >*
      mutable_vector_clock();

  // repeated .KeyVersion dependencies = 2;
  int dependencies_size() const;
  void clear_dependencies();
  static const int kDependenciesFieldNumber = 2;
  ::KeyVersion* mutable_dependencies(int index);
  ::google::protobuf::RepeatedPtrField< ::KeyVersion >*
      mutable_dependencies();
  const ::KeyVersion& dependencies(int index) const;
  ::KeyVersion* add_dependencies();
  const ::google::protobuf::RepeatedPtrField< ::KeyVersion >&
      dependencies() const;

  // repeated bytes values = 3;
  int values_size() const;
  void clear_values();
  static const int kValuesFieldNumber = 3;
  const ::std::string& values(int index) const;
  ::std::string* mutable_values(int index);
  void set_values(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_values(int index, ::std::string&& value);
  #endif
  void set_values(int index, const char* value);
  void set_values(int index, const void* value, size_t size);
  ::std::string* add_values();
  void add_values(const ::std::string& value);
  #if LANG_CXX11
  void add_values(::std::string&& value);
  #endif
  void add_values(const char* value);
  void add_values(const void* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& values() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_values();

  // @@protoc_insertion_point(class_scope:MultiKeyCausalValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::MapField<
      MultiKeyCausalValue_VectorClockEntry_DoNotUse,
      ::std::string, ::google::protobuf::uint32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_UINT32,
      0 > vector_clock_;
  ::google::protobuf::RepeatedPtrField< ::KeyVersion > dependencies_;
  ::google::protobuf::RepeatedPtrField< ::std::string> values_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class PriorityValue : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:PriorityValue) */ {
 public:
  PriorityValue();
  virtual ~PriorityValue();

  PriorityValue(const PriorityValue& from);

  inline PriorityValue& operator=(const PriorityValue& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PriorityValue(PriorityValue&& from) noexcept
    : PriorityValue() {
    *this = ::std::move(from);
  }

  inline PriorityValue& operator=(PriorityValue&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const PriorityValue& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PriorityValue* internal_default_instance() {
    return reinterpret_cast<const PriorityValue*>(
               &_PriorityValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(PriorityValue* other);
  friend void swap(PriorityValue& a, PriorityValue& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PriorityValue* New() const final {
    return CreateMaybeMessage<PriorityValue>(NULL);
  }

  PriorityValue* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PriorityValue>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PriorityValue& from);
  void MergeFrom(const PriorityValue& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PriorityValue* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // bytes value = 2;
  void clear_value();
  static const int kValueFieldNumber = 2;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // double priority = 1;
  void clear_priority();
  static const int kPriorityFieldNumber = 1;
  double priority() const;
  void set_priority(double value);

  // @@protoc_insertion_point(class_scope:PriorityValue)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  double priority_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_anna_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StringSet

// repeated string keys = 1;
inline int StringSet::keys_size() const {
  return keys_.size();
}
inline void StringSet::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& StringSet::keys(int index) const {
  // @@protoc_insertion_point(field_get:StringSet.keys)
  return keys_.Get(index);
}
inline ::std::string* StringSet::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:StringSet.keys)
  return keys_.Mutable(index);
}
inline void StringSet::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:StringSet.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void StringSet::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:StringSet.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void StringSet::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:StringSet.keys)
}
inline void StringSet::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StringSet.keys)
}
inline ::std::string* StringSet::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:StringSet.keys)
  return keys_.Add();
}
inline void StringSet::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:StringSet.keys)
}
#if LANG_CXX11
inline void StringSet::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:StringSet.keys)
}
#endif
inline void StringSet::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:StringSet.keys)
}
inline void StringSet::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:StringSet.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
StringSet::keys() const {
  // @@protoc_insertion_point(field_list:StringSet.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
StringSet::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:StringSet.keys)
  return &keys_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// KeyVersion

// string key = 1;
inline void KeyVersion::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyVersion::key() const {
  // @@protoc_insertion_point(field_get:KeyVersion.key)
  return key_.GetNoArena();
}
inline void KeyVersion::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyVersion.key)
}
#if LANG_CXX11
inline void KeyVersion::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyVersion.key)
}
#endif
inline void KeyVersion::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyVersion.key)
}
inline void KeyVersion::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyVersion.key)
}
inline ::std::string* KeyVersion::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:KeyVersion.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyVersion::release_key() {
  // @@protoc_insertion_point(field_release:KeyVersion.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyVersion::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:KeyVersion.key)
}

// map<string, uint32> vector_clock = 2;
inline int KeyVersion::vector_clock_size() const {
  return vector_clock_.size();
}
inline void KeyVersion::clear_vector_clock() {
  vector_clock_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >&
KeyVersion::vector_clock() const {
  // @@protoc_insertion_point(field_map:KeyVersion.vector_clock)
  return vector_clock_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >*
KeyVersion::mutable_vector_clock() {
  // @@protoc_insertion_point(field_mutable_map:KeyVersion.vector_clock)
  return vector_clock_.MutableMap();
}

// -------------------------------------------------------------------

// KeyVersionList

// repeated .KeyVersion keys = 1;
inline int KeyVersionList::keys_size() const {
  return keys_.size();
}
inline void KeyVersionList::clear_keys() {
  keys_.Clear();
}
inline ::KeyVersion* KeyVersionList::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:KeyVersionList.keys)
  return keys_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyVersion >*
KeyVersionList::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:KeyVersionList.keys)
  return &keys_;
}
inline const ::KeyVersion& KeyVersionList::keys(int index) const {
  // @@protoc_insertion_point(field_get:KeyVersionList.keys)
  return keys_.Get(index);
}
inline ::KeyVersion* KeyVersionList::add_keys() {
  // @@protoc_insertion_point(field_add:KeyVersionList.keys)
  return keys_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyVersion >&
KeyVersionList::keys() const {
  // @@protoc_insertion_point(field_list:KeyVersionList.keys)
  return keys_;
}

// -------------------------------------------------------------------

// KeyTuple

// string key = 1;
inline void KeyTuple::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyTuple::key() const {
  // @@protoc_insertion_point(field_get:KeyTuple.key)
  return key_.GetNoArena();
}
inline void KeyTuple::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyTuple.key)
}
#if LANG_CXX11
inline void KeyTuple::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyTuple.key)
}
#endif
inline void KeyTuple::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyTuple.key)
}
inline void KeyTuple::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyTuple.key)
}
inline ::std::string* KeyTuple::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:KeyTuple.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyTuple::release_key() {
  // @@protoc_insertion_point(field_release:KeyTuple.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyTuple::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:KeyTuple.key)
}

// .LatticeType lattice_type = 2;
inline void KeyTuple::clear_lattice_type() {
  lattice_type_ = 0;
}
inline ::LatticeType KeyTuple::lattice_type() const {
  // @@protoc_insertion_point(field_get:KeyTuple.lattice_type)
  return static_cast< ::LatticeType >(lattice_type_);
}
inline void KeyTuple::set_lattice_type(::LatticeType value) {
  
  lattice_type_ = value;
  // @@protoc_insertion_point(field_set:KeyTuple.lattice_type)
}

// .AnnaError error = 3;
inline void KeyTuple::clear_error() {
  error_ = 0;
}
inline ::AnnaError KeyTuple::error() const {
  // @@protoc_insertion_point(field_get:KeyTuple.error)
  return static_cast< ::AnnaError >(error_);
}
inline void KeyTuple::set_error(::AnnaError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:KeyTuple.error)
}

// bytes payload = 4;
inline void KeyTuple::clear_payload() {
  payload_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyTuple::payload() const {
  // @@protoc_insertion_point(field_get:KeyTuple.payload)
  return payload_.GetNoArena();
}
inline void KeyTuple::set_payload(const ::std::string& value) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyTuple.payload)
}
#if LANG_CXX11
inline void KeyTuple::set_payload(::std::string&& value) {
  
  payload_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyTuple.payload)
}
#endif
inline void KeyTuple::set_payload(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyTuple.payload)
}
inline void KeyTuple::set_payload(const void* value, size_t size) {
  
  payload_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyTuple.payload)
}
inline ::std::string* KeyTuple::mutable_payload() {
  
  // @@protoc_insertion_point(field_mutable:KeyTuple.payload)
  return payload_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyTuple::release_payload() {
  // @@protoc_insertion_point(field_release:KeyTuple.payload)
  
  return payload_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyTuple::set_allocated_payload(::std::string* payload) {
  if (payload != NULL) {
    
  } else {
    
  }
  payload_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), payload);
  // @@protoc_insertion_point(field_set_allocated:KeyTuple.payload)
}

// uint32 address_cache_size = 5;
inline void KeyTuple::clear_address_cache_size() {
  address_cache_size_ = 0u;
}
inline ::google::protobuf::uint32 KeyTuple::address_cache_size() const {
  // @@protoc_insertion_point(field_get:KeyTuple.address_cache_size)
  return address_cache_size_;
}
inline void KeyTuple::set_address_cache_size(::google::protobuf::uint32 value) {
  
  address_cache_size_ = value;
  // @@protoc_insertion_point(field_set:KeyTuple.address_cache_size)
}

// bool invalidate = 6;
inline void KeyTuple::clear_invalidate() {
  invalidate_ = false;
}
inline bool KeyTuple::invalidate() const {
  // @@protoc_insertion_point(field_get:KeyTuple.invalidate)
  return invalidate_;
}
inline void KeyTuple::set_invalidate(bool value) {
  
  invalidate_ = value;
  // @@protoc_insertion_point(field_set:KeyTuple.invalidate)
}

// -------------------------------------------------------------------

// KeyRequest

// .RequestType type = 1;
inline void KeyRequest::clear_type() {
  type_ = 0;
}
inline ::RequestType KeyRequest::type() const {
  // @@protoc_insertion_point(field_get:KeyRequest.type)
  return static_cast< ::RequestType >(type_);
}
inline void KeyRequest::set_type(::RequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:KeyRequest.type)
}

// repeated .KeyTuple tuples = 2;
inline int KeyRequest::tuples_size() const {
  return tuples_.size();
}
inline void KeyRequest::clear_tuples() {
  tuples_.Clear();
}
inline ::KeyTuple* KeyRequest::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:KeyRequest.tuples)
  return tuples_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyTuple >*
KeyRequest::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:KeyRequest.tuples)
  return &tuples_;
}
inline const ::KeyTuple& KeyRequest::tuples(int index) const {
  // @@protoc_insertion_point(field_get:KeyRequest.tuples)
  return tuples_.Get(index);
}
inline ::KeyTuple* KeyRequest::add_tuples() {
  // @@protoc_insertion_point(field_add:KeyRequest.tuples)
  return tuples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyTuple >&
KeyRequest::tuples() const {
  // @@protoc_insertion_point(field_list:KeyRequest.tuples)
  return tuples_;
}

// string response_address = 3;
inline void KeyRequest::clear_response_address() {
  response_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyRequest::response_address() const {
  // @@protoc_insertion_point(field_get:KeyRequest.response_address)
  return response_address_.GetNoArena();
}
inline void KeyRequest::set_response_address(const ::std::string& value) {
  
  response_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyRequest.response_address)
}
#if LANG_CXX11
inline void KeyRequest::set_response_address(::std::string&& value) {
  
  response_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyRequest.response_address)
}
#endif
inline void KeyRequest::set_response_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyRequest.response_address)
}
inline void KeyRequest::set_response_address(const char* value, size_t size) {
  
  response_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyRequest.response_address)
}
inline ::std::string* KeyRequest::mutable_response_address() {
  
  // @@protoc_insertion_point(field_mutable:KeyRequest.response_address)
  return response_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyRequest::release_response_address() {
  // @@protoc_insertion_point(field_release:KeyRequest.response_address)
  
  return response_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyRequest::set_allocated_response_address(::std::string* response_address) {
  if (response_address != NULL) {
    
  } else {
    
  }
  response_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_address);
  // @@protoc_insertion_point(field_set_allocated:KeyRequest.response_address)
}

// string request_id = 4;
inline void KeyRequest::clear_request_id() {
  request_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyRequest::request_id() const {
  // @@protoc_insertion_point(field_get:KeyRequest.request_id)
  return request_id_.GetNoArena();
}
inline void KeyRequest::set_request_id(const ::std::string& value) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyRequest.request_id)
}
#if LANG_CXX11
inline void KeyRequest::set_request_id(::std::string&& value) {
  
  request_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyRequest.request_id)
}
#endif
inline void KeyRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyRequest.request_id)
}
inline void KeyRequest::set_request_id(const char* value, size_t size) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyRequest.request_id)
}
inline ::std::string* KeyRequest::mutable_request_id() {
  
  // @@protoc_insertion_point(field_mutable:KeyRequest.request_id)
  return request_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:KeyRequest.request_id)
  
  return request_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyRequest::set_allocated_request_id(::std::string* request_id) {
  if (request_id != NULL) {
    
  } else {
    
  }
  request_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_id);
  // @@protoc_insertion_point(field_set_allocated:KeyRequest.request_id)
}

// -------------------------------------------------------------------

// KeyResponse

// .RequestType type = 1;
inline void KeyResponse::clear_type() {
  type_ = 0;
}
inline ::RequestType KeyResponse::type() const {
  // @@protoc_insertion_point(field_get:KeyResponse.type)
  return static_cast< ::RequestType >(type_);
}
inline void KeyResponse::set_type(::RequestType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:KeyResponse.type)
}

// repeated .KeyTuple tuples = 2;
inline int KeyResponse::tuples_size() const {
  return tuples_.size();
}
inline void KeyResponse::clear_tuples() {
  tuples_.Clear();
}
inline ::KeyTuple* KeyResponse::mutable_tuples(int index) {
  // @@protoc_insertion_point(field_mutable:KeyResponse.tuples)
  return tuples_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyTuple >*
KeyResponse::mutable_tuples() {
  // @@protoc_insertion_point(field_mutable_list:KeyResponse.tuples)
  return &tuples_;
}
inline const ::KeyTuple& KeyResponse::tuples(int index) const {
  // @@protoc_insertion_point(field_get:KeyResponse.tuples)
  return tuples_.Get(index);
}
inline ::KeyTuple* KeyResponse::add_tuples() {
  // @@protoc_insertion_point(field_add:KeyResponse.tuples)
  return tuples_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyTuple >&
KeyResponse::tuples() const {
  // @@protoc_insertion_point(field_list:KeyResponse.tuples)
  return tuples_;
}

// string response_id = 3;
inline void KeyResponse::clear_response_id() {
  response_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyResponse::response_id() const {
  // @@protoc_insertion_point(field_get:KeyResponse.response_id)
  return response_id_.GetNoArena();
}
inline void KeyResponse::set_response_id(const ::std::string& value) {
  
  response_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyResponse.response_id)
}
#if LANG_CXX11
inline void KeyResponse::set_response_id(::std::string&& value) {
  
  response_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyResponse.response_id)
}
#endif
inline void KeyResponse::set_response_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyResponse.response_id)
}
inline void KeyResponse::set_response_id(const char* value, size_t size) {
  
  response_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyResponse.response_id)
}
inline ::std::string* KeyResponse::mutable_response_id() {
  
  // @@protoc_insertion_point(field_mutable:KeyResponse.response_id)
  return response_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyResponse::release_response_id() {
  // @@protoc_insertion_point(field_release:KeyResponse.response_id)
  
  return response_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyResponse::set_allocated_response_id(::std::string* response_id) {
  if (response_id != NULL) {
    
  } else {
    
  }
  response_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_id);
  // @@protoc_insertion_point(field_set_allocated:KeyResponse.response_id)
}

// .AnnaError error = 4;
inline void KeyResponse::clear_error() {
  error_ = 0;
}
inline ::AnnaError KeyResponse::error() const {
  // @@protoc_insertion_point(field_get:KeyResponse.error)
  return static_cast< ::AnnaError >(error_);
}
inline void KeyResponse::set_error(::AnnaError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:KeyResponse.error)
}

// -------------------------------------------------------------------

// KeyAddressRequest

// string response_address = 1;
inline void KeyAddressRequest::clear_response_address() {
  response_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyAddressRequest::response_address() const {
  // @@protoc_insertion_point(field_get:KeyAddressRequest.response_address)
  return response_address_.GetNoArena();
}
inline void KeyAddressRequest::set_response_address(const ::std::string& value) {
  
  response_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyAddressRequest.response_address)
}
#if LANG_CXX11
inline void KeyAddressRequest::set_response_address(::std::string&& value) {
  
  response_address_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyAddressRequest.response_address)
}
#endif
inline void KeyAddressRequest::set_response_address(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyAddressRequest.response_address)
}
inline void KeyAddressRequest::set_response_address(const char* value, size_t size) {
  
  response_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyAddressRequest.response_address)
}
inline ::std::string* KeyAddressRequest::mutable_response_address() {
  
  // @@protoc_insertion_point(field_mutable:KeyAddressRequest.response_address)
  return response_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyAddressRequest::release_response_address() {
  // @@protoc_insertion_point(field_release:KeyAddressRequest.response_address)
  
  return response_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyAddressRequest::set_allocated_response_address(::std::string* response_address) {
  if (response_address != NULL) {
    
  } else {
    
  }
  response_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_address);
  // @@protoc_insertion_point(field_set_allocated:KeyAddressRequest.response_address)
}

// repeated string keys = 2;
inline int KeyAddressRequest::keys_size() const {
  return keys_.size();
}
inline void KeyAddressRequest::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& KeyAddressRequest::keys(int index) const {
  // @@protoc_insertion_point(field_get:KeyAddressRequest.keys)
  return keys_.Get(index);
}
inline ::std::string* KeyAddressRequest::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:KeyAddressRequest.keys)
  return keys_.Mutable(index);
}
inline void KeyAddressRequest::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KeyAddressRequest.keys)
  keys_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KeyAddressRequest::set_keys(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:KeyAddressRequest.keys)
  keys_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KeyAddressRequest::set_keys(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KeyAddressRequest.keys)
}
inline void KeyAddressRequest::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KeyAddressRequest.keys)
}
inline ::std::string* KeyAddressRequest::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:KeyAddressRequest.keys)
  return keys_.Add();
}
inline void KeyAddressRequest::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KeyAddressRequest.keys)
}
#if LANG_CXX11
inline void KeyAddressRequest::add_keys(::std::string&& value) {
  keys_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:KeyAddressRequest.keys)
}
#endif
inline void KeyAddressRequest::add_keys(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KeyAddressRequest.keys)
}
inline void KeyAddressRequest::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KeyAddressRequest.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KeyAddressRequest::keys() const {
  // @@protoc_insertion_point(field_list:KeyAddressRequest.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KeyAddressRequest::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:KeyAddressRequest.keys)
  return &keys_;
}

// string request_id = 3;
inline void KeyAddressRequest::clear_request_id() {
  request_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyAddressRequest::request_id() const {
  // @@protoc_insertion_point(field_get:KeyAddressRequest.request_id)
  return request_id_.GetNoArena();
}
inline void KeyAddressRequest::set_request_id(const ::std::string& value) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyAddressRequest.request_id)
}
#if LANG_CXX11
inline void KeyAddressRequest::set_request_id(::std::string&& value) {
  
  request_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyAddressRequest.request_id)
}
#endif
inline void KeyAddressRequest::set_request_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyAddressRequest.request_id)
}
inline void KeyAddressRequest::set_request_id(const char* value, size_t size) {
  
  request_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyAddressRequest.request_id)
}
inline ::std::string* KeyAddressRequest::mutable_request_id() {
  
  // @@protoc_insertion_point(field_mutable:KeyAddressRequest.request_id)
  return request_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyAddressRequest::release_request_id() {
  // @@protoc_insertion_point(field_release:KeyAddressRequest.request_id)
  
  return request_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyAddressRequest::set_allocated_request_id(::std::string* request_id) {
  if (request_id != NULL) {
    
  } else {
    
  }
  request_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), request_id);
  // @@protoc_insertion_point(field_set_allocated:KeyAddressRequest.request_id)
}

// -------------------------------------------------------------------

// KeyAddressResponse_KeyAddress

// string key = 1;
inline void KeyAddressResponse_KeyAddress::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyAddressResponse_KeyAddress::key() const {
  // @@protoc_insertion_point(field_get:KeyAddressResponse.KeyAddress.key)
  return key_.GetNoArena();
}
inline void KeyAddressResponse_KeyAddress::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyAddressResponse.KeyAddress.key)
}
#if LANG_CXX11
inline void KeyAddressResponse_KeyAddress::set_key(::std::string&& value) {
  
  key_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyAddressResponse.KeyAddress.key)
}
#endif
inline void KeyAddressResponse_KeyAddress::set_key(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyAddressResponse.KeyAddress.key)
}
inline void KeyAddressResponse_KeyAddress::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyAddressResponse.KeyAddress.key)
}
inline ::std::string* KeyAddressResponse_KeyAddress::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:KeyAddressResponse.KeyAddress.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyAddressResponse_KeyAddress::release_key() {
  // @@protoc_insertion_point(field_release:KeyAddressResponse.KeyAddress.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyAddressResponse_KeyAddress::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:KeyAddressResponse.KeyAddress.key)
}

// repeated string ips = 2;
inline int KeyAddressResponse_KeyAddress::ips_size() const {
  return ips_.size();
}
inline void KeyAddressResponse_KeyAddress::clear_ips() {
  ips_.Clear();
}
inline const ::std::string& KeyAddressResponse_KeyAddress::ips(int index) const {
  // @@protoc_insertion_point(field_get:KeyAddressResponse.KeyAddress.ips)
  return ips_.Get(index);
}
inline ::std::string* KeyAddressResponse_KeyAddress::mutable_ips(int index) {
  // @@protoc_insertion_point(field_mutable:KeyAddressResponse.KeyAddress.ips)
  return ips_.Mutable(index);
}
inline void KeyAddressResponse_KeyAddress::set_ips(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:KeyAddressResponse.KeyAddress.ips)
  ips_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void KeyAddressResponse_KeyAddress::set_ips(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:KeyAddressResponse.KeyAddress.ips)
  ips_.Mutable(index)->assign(std::move(value));
}
#endif
inline void KeyAddressResponse_KeyAddress::set_ips(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ips_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:KeyAddressResponse.KeyAddress.ips)
}
inline void KeyAddressResponse_KeyAddress::set_ips(int index, const char* value, size_t size) {
  ips_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:KeyAddressResponse.KeyAddress.ips)
}
inline ::std::string* KeyAddressResponse_KeyAddress::add_ips() {
  // @@protoc_insertion_point(field_add_mutable:KeyAddressResponse.KeyAddress.ips)
  return ips_.Add();
}
inline void KeyAddressResponse_KeyAddress::add_ips(const ::std::string& value) {
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:KeyAddressResponse.KeyAddress.ips)
}
#if LANG_CXX11
inline void KeyAddressResponse_KeyAddress::add_ips(::std::string&& value) {
  ips_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:KeyAddressResponse.KeyAddress.ips)
}
#endif
inline void KeyAddressResponse_KeyAddress::add_ips(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  ips_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:KeyAddressResponse.KeyAddress.ips)
}
inline void KeyAddressResponse_KeyAddress::add_ips(const char* value, size_t size) {
  ips_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:KeyAddressResponse.KeyAddress.ips)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
KeyAddressResponse_KeyAddress::ips() const {
  // @@protoc_insertion_point(field_list:KeyAddressResponse.KeyAddress.ips)
  return ips_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
KeyAddressResponse_KeyAddress::mutable_ips() {
  // @@protoc_insertion_point(field_mutable_list:KeyAddressResponse.KeyAddress.ips)
  return &ips_;
}

// -------------------------------------------------------------------

// KeyAddressResponse

// repeated .KeyAddressResponse.KeyAddress addresses = 1;
inline int KeyAddressResponse::addresses_size() const {
  return addresses_.size();
}
inline void KeyAddressResponse::clear_addresses() {
  addresses_.Clear();
}
inline ::KeyAddressResponse_KeyAddress* KeyAddressResponse::mutable_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:KeyAddressResponse.addresses)
  return addresses_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyAddressResponse_KeyAddress >*
KeyAddressResponse::mutable_addresses() {
  // @@protoc_insertion_point(field_mutable_list:KeyAddressResponse.addresses)
  return &addresses_;
}
inline const ::KeyAddressResponse_KeyAddress& KeyAddressResponse::addresses(int index) const {
  // @@protoc_insertion_point(field_get:KeyAddressResponse.addresses)
  return addresses_.Get(index);
}
inline ::KeyAddressResponse_KeyAddress* KeyAddressResponse::add_addresses() {
  // @@protoc_insertion_point(field_add:KeyAddressResponse.addresses)
  return addresses_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyAddressResponse_KeyAddress >&
KeyAddressResponse::addresses() const {
  // @@protoc_insertion_point(field_list:KeyAddressResponse.addresses)
  return addresses_;
}

// .AnnaError error = 2;
inline void KeyAddressResponse::clear_error() {
  error_ = 0;
}
inline ::AnnaError KeyAddressResponse::error() const {
  // @@protoc_insertion_point(field_get:KeyAddressResponse.error)
  return static_cast< ::AnnaError >(error_);
}
inline void KeyAddressResponse::set_error(::AnnaError value) {
  
  error_ = value;
  // @@protoc_insertion_point(field_set:KeyAddressResponse.error)
}

// string response_id = 3;
inline void KeyAddressResponse::clear_response_id() {
  response_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& KeyAddressResponse::response_id() const {
  // @@protoc_insertion_point(field_get:KeyAddressResponse.response_id)
  return response_id_.GetNoArena();
}
inline void KeyAddressResponse::set_response_id(const ::std::string& value) {
  
  response_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:KeyAddressResponse.response_id)
}
#if LANG_CXX11
inline void KeyAddressResponse::set_response_id(::std::string&& value) {
  
  response_id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:KeyAddressResponse.response_id)
}
#endif
inline void KeyAddressResponse::set_response_id(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  response_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:KeyAddressResponse.response_id)
}
inline void KeyAddressResponse::set_response_id(const char* value, size_t size) {
  
  response_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:KeyAddressResponse.response_id)
}
inline ::std::string* KeyAddressResponse::mutable_response_id() {
  
  // @@protoc_insertion_point(field_mutable:KeyAddressResponse.response_id)
  return response_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* KeyAddressResponse::release_response_id() {
  // @@protoc_insertion_point(field_release:KeyAddressResponse.response_id)
  
  return response_id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void KeyAddressResponse::set_allocated_response_id(::std::string* response_id) {
  if (response_id != NULL) {
    
  } else {
    
  }
  response_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), response_id);
  // @@protoc_insertion_point(field_set_allocated:KeyAddressResponse.response_id)
}

// -------------------------------------------------------------------

// LWWValue

// uint64 timestamp = 1;
inline void LWWValue::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 LWWValue::timestamp() const {
  // @@protoc_insertion_point(field_get:LWWValue.timestamp)
  return timestamp_;
}
inline void LWWValue::set_timestamp(::google::protobuf::uint64 value) {
  
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:LWWValue.timestamp)
}

// bytes value = 2;
inline void LWWValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& LWWValue::value() const {
  // @@protoc_insertion_point(field_get:LWWValue.value)
  return value_.GetNoArena();
}
inline void LWWValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:LWWValue.value)
}
#if LANG_CXX11
inline void LWWValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:LWWValue.value)
}
#endif
inline void LWWValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:LWWValue.value)
}
inline void LWWValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:LWWValue.value)
}
inline ::std::string* LWWValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:LWWValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* LWWValue::release_value() {
  // @@protoc_insertion_point(field_release:LWWValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void LWWValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:LWWValue.value)
}

// -------------------------------------------------------------------

// SetValue

// repeated bytes values = 1;
inline int SetValue::values_size() const {
  return values_.size();
}
inline void SetValue::clear_values() {
  values_.Clear();
}
inline const ::std::string& SetValue::values(int index) const {
  // @@protoc_insertion_point(field_get:SetValue.values)
  return values_.Get(index);
}
inline ::std::string* SetValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:SetValue.values)
  return values_.Mutable(index);
}
inline void SetValue::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SetValue.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SetValue::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SetValue.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SetValue::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SetValue.values)
}
inline void SetValue::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SetValue.values)
}
inline ::std::string* SetValue::add_values() {
  // @@protoc_insertion_point(field_add_mutable:SetValue.values)
  return values_.Add();
}
inline void SetValue::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SetValue.values)
}
#if LANG_CXX11
inline void SetValue::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SetValue.values)
}
#endif
inline void SetValue::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SetValue.values)
}
inline void SetValue::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SetValue.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SetValue::values() const {
  // @@protoc_insertion_point(field_list:SetValue.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SetValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:SetValue.values)
  return &values_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// SingleKeyCausalValue

// map<string, uint32> vector_clock = 1;
inline int SingleKeyCausalValue::vector_clock_size() const {
  return vector_clock_.size();
}
inline void SingleKeyCausalValue::clear_vector_clock() {
  vector_clock_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >&
SingleKeyCausalValue::vector_clock() const {
  // @@protoc_insertion_point(field_map:SingleKeyCausalValue.vector_clock)
  return vector_clock_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >*
SingleKeyCausalValue::mutable_vector_clock() {
  // @@protoc_insertion_point(field_mutable_map:SingleKeyCausalValue.vector_clock)
  return vector_clock_.MutableMap();
}

// repeated bytes values = 2;
inline int SingleKeyCausalValue::values_size() const {
  return values_.size();
}
inline void SingleKeyCausalValue::clear_values() {
  values_.Clear();
}
inline const ::std::string& SingleKeyCausalValue::values(int index) const {
  // @@protoc_insertion_point(field_get:SingleKeyCausalValue.values)
  return values_.Get(index);
}
inline ::std::string* SingleKeyCausalValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:SingleKeyCausalValue.values)
  return values_.Mutable(index);
}
inline void SingleKeyCausalValue::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:SingleKeyCausalValue.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void SingleKeyCausalValue::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:SingleKeyCausalValue.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void SingleKeyCausalValue::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:SingleKeyCausalValue.values)
}
inline void SingleKeyCausalValue::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:SingleKeyCausalValue.values)
}
inline ::std::string* SingleKeyCausalValue::add_values() {
  // @@protoc_insertion_point(field_add_mutable:SingleKeyCausalValue.values)
  return values_.Add();
}
inline void SingleKeyCausalValue::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:SingleKeyCausalValue.values)
}
#if LANG_CXX11
inline void SingleKeyCausalValue::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:SingleKeyCausalValue.values)
}
#endif
inline void SingleKeyCausalValue::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:SingleKeyCausalValue.values)
}
inline void SingleKeyCausalValue::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:SingleKeyCausalValue.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
SingleKeyCausalValue::values() const {
  // @@protoc_insertion_point(field_list:SingleKeyCausalValue.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
SingleKeyCausalValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:SingleKeyCausalValue.values)
  return &values_;
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// MultiKeyCausalValue

// map<string, uint32> vector_clock = 1;
inline int MultiKeyCausalValue::vector_clock_size() const {
  return vector_clock_.size();
}
inline void MultiKeyCausalValue::clear_vector_clock() {
  vector_clock_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >&
MultiKeyCausalValue::vector_clock() const {
  // @@protoc_insertion_point(field_map:MultiKeyCausalValue.vector_clock)
  return vector_clock_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::uint32 >*
MultiKeyCausalValue::mutable_vector_clock() {
  // @@protoc_insertion_point(field_mutable_map:MultiKeyCausalValue.vector_clock)
  return vector_clock_.MutableMap();
}

// repeated .KeyVersion dependencies = 2;
inline int MultiKeyCausalValue::dependencies_size() const {
  return dependencies_.size();
}
inline void MultiKeyCausalValue::clear_dependencies() {
  dependencies_.Clear();
}
inline ::KeyVersion* MultiKeyCausalValue::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:MultiKeyCausalValue.dependencies)
  return dependencies_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::KeyVersion >*
MultiKeyCausalValue::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:MultiKeyCausalValue.dependencies)
  return &dependencies_;
}
inline const ::KeyVersion& MultiKeyCausalValue::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:MultiKeyCausalValue.dependencies)
  return dependencies_.Get(index);
}
inline ::KeyVersion* MultiKeyCausalValue::add_dependencies() {
  // @@protoc_insertion_point(field_add:MultiKeyCausalValue.dependencies)
  return dependencies_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::KeyVersion >&
MultiKeyCausalValue::dependencies() const {
  // @@protoc_insertion_point(field_list:MultiKeyCausalValue.dependencies)
  return dependencies_;
}

// repeated bytes values = 3;
inline int MultiKeyCausalValue::values_size() const {
  return values_.size();
}
inline void MultiKeyCausalValue::clear_values() {
  values_.Clear();
}
inline const ::std::string& MultiKeyCausalValue::values(int index) const {
  // @@protoc_insertion_point(field_get:MultiKeyCausalValue.values)
  return values_.Get(index);
}
inline ::std::string* MultiKeyCausalValue::mutable_values(int index) {
  // @@protoc_insertion_point(field_mutable:MultiKeyCausalValue.values)
  return values_.Mutable(index);
}
inline void MultiKeyCausalValue::set_values(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:MultiKeyCausalValue.values)
  values_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void MultiKeyCausalValue::set_values(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:MultiKeyCausalValue.values)
  values_.Mutable(index)->assign(std::move(value));
}
#endif
inline void MultiKeyCausalValue::set_values(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:MultiKeyCausalValue.values)
}
inline void MultiKeyCausalValue::set_values(int index, const void* value, size_t size) {
  values_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:MultiKeyCausalValue.values)
}
inline ::std::string* MultiKeyCausalValue::add_values() {
  // @@protoc_insertion_point(field_add_mutable:MultiKeyCausalValue.values)
  return values_.Add();
}
inline void MultiKeyCausalValue::add_values(const ::std::string& value) {
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:MultiKeyCausalValue.values)
}
#if LANG_CXX11
inline void MultiKeyCausalValue::add_values(::std::string&& value) {
  values_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:MultiKeyCausalValue.values)
}
#endif
inline void MultiKeyCausalValue::add_values(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  values_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:MultiKeyCausalValue.values)
}
inline void MultiKeyCausalValue::add_values(const void* value, size_t size) {
  values_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:MultiKeyCausalValue.values)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
MultiKeyCausalValue::values() const {
  // @@protoc_insertion_point(field_list:MultiKeyCausalValue.values)
  return values_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
MultiKeyCausalValue::mutable_values() {
  // @@protoc_insertion_point(field_mutable_list:MultiKeyCausalValue.values)
  return &values_;
}

// -------------------------------------------------------------------

// PriorityValue

// double priority = 1;
inline void PriorityValue::clear_priority() {
  priority_ = 0;
}
inline double PriorityValue::priority() const {
  // @@protoc_insertion_point(field_get:PriorityValue.priority)
  return priority_;
}
inline void PriorityValue::set_priority(double value) {
  
  priority_ = value;
  // @@protoc_insertion_point(field_set:PriorityValue.priority)
}

// bytes value = 2;
inline void PriorityValue::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PriorityValue::value() const {
  // @@protoc_insertion_point(field_get:PriorityValue.value)
  return value_.GetNoArena();
}
inline void PriorityValue::set_value(const ::std::string& value) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:PriorityValue.value)
}
#if LANG_CXX11
inline void PriorityValue::set_value(::std::string&& value) {
  
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:PriorityValue.value)
}
#endif
inline void PriorityValue::set_value(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:PriorityValue.value)
}
inline void PriorityValue::set_value(const void* value, size_t size) {
  
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:PriorityValue.value)
}
inline ::std::string* PriorityValue::mutable_value() {
  
  // @@protoc_insertion_point(field_mutable:PriorityValue.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PriorityValue::release_value() {
  // @@protoc_insertion_point(field_release:PriorityValue.value)
  
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PriorityValue::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    
  } else {
    
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:PriorityValue.value)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::RequestType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::RequestType>() {
  return ::RequestType_descriptor();
}
template <> struct is_proto_enum< ::LatticeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LatticeType>() {
  return ::LatticeType_descriptor();
}
template <> struct is_proto_enum< ::AnnaError> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AnnaError>() {
  return ::AnnaError_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_anna_2eproto
